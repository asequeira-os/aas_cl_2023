#|
based on spec at http://groups.google.com/group/json-rpc/web/json-rpc-2-0
* requests
rpc request object is sent to server. has following members:
jsonrpc "2.0"
method a:b  a is package b is method (should not start with "rpc."
params array or object. spec says structure only (no primitive). that is array or object. spec says optional.
id use a string or numeric identifier

* notification
just like request but without the id
server should not respond (even for errors)

* request/notification params
when array - they are expecte to match teh rpc call parameters b position
when object - match by name

* response
Response is a single JSON object with following memebers
jsonrpc "2.0"
result
required on success
must not exist if there is an error
value to be determined by the rpc method
error
required on error
must not exist if there was no error
format is defined below
id
required
must be same as the request id
should be null if there was an issue in the requests id detection

** response error object
object with following members
code
an integer
message
says short description limited to a concise sentense
data
additional info. may be omitted

*** predefined errors
-32700 json parse error
-32600 not a valid request object
-32601 method not found
-32602 invalid method parameters
-32603 internal json-rpc error
-32099 to -32000 server error - reserved for implementation defined server errors
remaining are allowed for application errors

* batch
an array of request objects would be a batch
|#

(in-package :aas-rpc)

(defparameter *optimize-local-calls* t)

(define-constant +hunchentoot-utf8+ (flex:make-external-format :utf-8 :eol-style :lf))
;;control the reading encoding
(setf hunchentoot:*hunchentoot-default-external-format* +hunchentoot-utf8+  )

(defun json-rpc-2-server-http ()
  (let ((*client-ip* (aas-http-server:client-ip))
        (*secure-transport* (aas-http-server:https-p))
        (*accept-language* (aas-http-server:accept-language))
        (*post-request* (aas-http-server:post-p)))
    (let ((package-method-s (get-http-param "method"))
          (from-host (get-http-param "host"))
          (host-token (get-http-param "token"))
          (json-request (get-http-param "request")))
      ;;todo 2 content length should be octets
      ;;control the writing encoding
      (setf (hunchentoot:reply-external-format* ) +hunchentoot-utf8+)
      (setf (hunchentoot:content-type*) "text/json; charset=utf-8")
      (setf hunchentoot:*catch-errors-p* t)
      (let ((resp (json-rpc-2-server from-host host-token package-method-s json-request)))
        (setf (hunchentoot:content-length*) (length resp))
        ;;to allow XHR XDM cross site scripting
        ;;todo 2 need better XHR access control
        (setf (hunchentoot:header-out "Access-Control-Allow-Origin") (hunchentoot:header-in* "Origin"))
        (setf (hunchentoot:header-out "Access-Control-Allow-Methods") "GET, POST")

        resp))))

(defparameter *debug-rpc-errors* nil   )

;;todo 2 generate http status 500 and fix ui to handle it
;;would need to set  hunchentoot:*catch-errors-p* to avoid debugger
;;500 can be generated by throwing any error
(defun json-rpc-2-server (from-host host-token package-method-s json-request)
  (handler-case
      (handler-bind
          ((error (lambda (e)
                    (declare (ignorable e))
                    (when *debug-rpc-errors*
                      ;;break without stack rewinding
                      (break)))))
        (log:with-logged-error
          (json-rpc-2-server-no-error
           from-host host-token package-method-s json-request)))
    (error (e)
      (encode-json-rpc-2-error-response e nil))))

(defun json-rpc-2-server-no-error
    (from-host host-token package-method-s json-request)
  (unless package-method-s
    (error "need method as http param"))
  (unless json-request
    (error "missing  request param"))
  (let* ((package-method (split-sequence:split-sequence
                          #\: package-method-s))
         (package (first package-method))
         (method (second package-method)))
    (let ((*trusted-host* ;;this only sets the trusted host
           (if host-token
               (verify-trust from-host host-token))))
      (unless (and package method)
        (error "invalid method"))
      (let ((rpc-meta (get-rpc-meta-data package method)))
        (unless rpc-meta
          (error "no info found on ~A" package-method-s))
        (with-input-from-string (json-stream json-request)
          (json-rpc-2-exec package method rpc-meta json-stream))))))

(defun json-rpc-2-exec (package method rpc-meta stream)
  (if (and (equal package "aas-rpc")
           (equal method  "json-rpc-2-batch"))
      (json-rpc-2-exec-batch stream)
      (multiple-value-bind (id  rpc-meta result)
          (json-rpc-2-exec-single package method rpc-meta stream)
        (with-output-to-string (stream)
          (encode-json-rpc-2-response id result (rpc-meta-return-type rpc-meta) stream)))))

(defun json-rpc-2-exec-batch (in-stream)
  (let ((list (json-rpc-2-exec-batch-list in-stream)))
    (with-output-to-string (stream)
      (sout-begin-object +json-format+ stream "response")
      (let ((comma nil))
        (dolist (resp-info list)
          (when comma
            (sout-add-comma +json-format+ stream))
          (setf comma t)
          (let ((id (first resp-info))
                (rpc-meta (second resp-info))
                (resp (third resp-info)))
            (json-print-attribute (format nil "id~A" id) stream)
            (encode-json-rpc-2-response
             id resp
             (rpc-meta-return-type rpc-meta) stream))))
      (sout-end-object +json-format+ stream "response"))))

(defun json-rpc-2-exec-batch-list (stream)
  (let ((resp-list (list)))
    (sin-begin-vector +json-format+ stream)
    (util:while (not (equal #\] (peek-char t stream)))
      (skip-optional-comma stream)
      (sin-begin-vector +json-format+ stream)
      ;;read the two elements
      (let ((package-method-s (deserialize-string +json-format+ stream 'string)))
        (skip-optional-comma stream)
        (let* ((package-method (split-sequence:split-sequence
                                #\: package-method-s))
               (package (first package-method))
               (method (second package-method)))
          (unless (and package method)
            (error "invalid method"))
          (let ((rpc-meta (get-rpc-meta-data package method)))
            (unless rpc-meta
              (error "no info found on ~A" package-method-s))
            ;;(break)
            (multiple-value-bind (id rpc-meta result)
                (json-rpc-2-exec-single package method rpc-meta stream)
              (push (list id rpc-meta result) resp-list)))))
      (sin-end-vector +json-format+ stream))
    (sin-end-vector +json-format+ stream)
    (nreverse resp-list)
    ))


(defun json-rpc-2-exec-single (package method rpc-meta stream)
  (sin-begin-object +json-format+ stream nil)
  (let ((id nil)
        (params nil)
        (*auth-token* nil)
        (*auth-user* nil)
        (*rpc-remote-depth* 0))
    (util:while (not (sin-end-object +json-format+ stream nil))
      (let ((key (sin-object-attr-name +json-format+ stream nil)))
        (sin-attr-name-value-seprator +json-format+ stream)
        (with-hashed-identity (:test #'equal)
          (case key
            ("method" (deserialize-string +json-format+ stream 'string))
            ("id" (setf id (deserialize-integer +json-format+ stream 'integer)))
            ("jsonrpc"
             (or (equal "2.0"
                        (deserialize-string +json-format+ stream 'string))
                 (error "jsonrpc should have been 2.0" )))
            ("params"
             (setf params (json-rpc-2-deserialize-params rpc-meta stream)))
            ("remote-depth"
             (setf *rpc-remote-depth*
                   (deserialize-integer +json-format+ stream 'integer)))
            ("xedauth"
             (setf *auth-token*
                   (funcall (gethash *auth-token-type* *deserializers*)
                            +json-format+ stream *auth-token-type*)))
            (t (error "unknown attribute ~A in json request " key))
            ))
        (sin-attr-separator  +json-format+ stream)))
    ;;(print *rpc-remote-depth*)
    (when (> *rpc-remote-depth* +rpc-remote-max-depth+)
      (error "remote max depth exceeded"))
    (values id rpc-meta
            (call-rpc-function package method params))))


(defun encode-json-rpc-2-response (id result result-type stream)
  (sout-begin-object +json-format+ stream "response")
  (sout-object-attr +json-format+ stream 'string "jsonrpc" "2.0")
  (sout-add-comma +json-format+ stream )
  (sout-object-attr +json-format+ stream 'number "id" id)
  (sout-add-comma +json-format+ stream )
  (json-print-attribute "result" stream)
  (sout-object +json-format+ stream result-type result)
  (sout-end-object +json-format+ stream "response"))

(def-rpc-struct json-rpc-2-error
    (code nil :type (or null integer))
  (scode nil :type (or null string))
  (message "" :type string)
  (i18nMsg "" :type string)
  (data "" :type string)
  (host "" :type string)
  (trace "" :type string)
  (cause nil :type (or null json-rpc-2-error)))

;;see over ride in cloud
(defmethod make-rpc-error (error)
  (make-json-rpc-2-error :code -32000
                         :scode "unknown_error"
                         :message (format nil "~A" error)
                         :i18nMsg "unknown error"
                         :data ""
                         :host (host:my-hostname)
                         :trace (print-backtrace error)
                         :cause nil))

(defmethod make-rpc-error ((rpc-error rpc-error))
  (let ((cause (rpc-error-cause rpc-error)))
    (make-json-rpc-2-error :code (json-rpc-2-error-code cause)
                           :scode (json-rpc-2-error-scode cause)
                           :message (concatenate 'string "-- "
                                                 (json-rpc-2-error-message cause))
                           :i18nMsg (json-rpc-2-error-i18nmsg cause)
                           :host (host:my-hostname)
                           :cause cause)))

(defun encode-json-rpc-2-error-response (err id)
  (with-output-to-string (stream)
    (sout-begin-object +json-format+ stream "response")
    (sout-object-attr +json-format+ stream 'string "jsonrpc" "2.0")
    (sout-add-comma +json-format+ stream )
    (sout-object-attr +json-format+ stream 'number "id" id)
    (sout-add-comma +json-format+ stream )
    (json-print-attribute "error" stream)
    (sout-object +json-format+ stream 'json-rpc-2-error (make-rpc-error err))
    (sout-end-object +json-format+ stream "response")))

(defun json-rpc-2-deserialize-params (rpc-meta stream)
  (let ((params (list))
        (arguments (rpc-meta-arguments rpc-meta)))
    (if arguments
        (progn
          (sin-begin-object +json-format+ stream nil)
          (util:while (not (sin-end-object +json-format+ stream nil))
            (let ((param-name (sin-object-attr-name +json-format+ stream nil)))
              (sin-attr-name-value-seprator +json-format+ stream)
              (let ((param-meta (get-rpc-param-meta rpc-meta param-name)))
                (let ((param-type (cdr param-meta)))
                  (let ((param (if (consp param-type)
                                   (deserialize-compound-type +json-format+ stream nil param-type)
                                   (funcall (get-deserializer param-type)
                                            +json-format+ stream param-type))))
                    (push (cons (car param-meta) param) params))))
              (sin-attr-separator  +json-format+ stream)))
          params)
        (progn
          (deserialize-null +json-format+ stream)))))


(define-constant +json-rpc-2-prefix+ "/json-rpc-2")

(register-handler +json-rpc-2-prefix+ 'json-rpc-2-server-http)

(let ((json-id 1)
      (lock (mp-make-lock "jsonrpcid")))
  (defun make-json-id ()
    (mp-with-lock (lock)
      (incf json-id))))

(defun json-method-string (package name)
  (concatenate 'string package ":" name))

(defun ctor-json-request-str (package name params rpc-meta auth-token)
  (let ((id (make-json-id)))
    (values
     (with-output-to-string (stream)
       (sout-begin-object +json-format+ stream "request")
       (sout-object-attr +json-format+ stream 'string "jsonrpc" "2.0")
       (sout-add-comma +json-format+ stream)
       (sout-object-attr +json-format+ stream 'string "method"
                         (json-method-string package name))
       (sout-add-comma +json-format+ stream)
       (json-print-attribute "params" stream)
       (sout-assoc-list +json-format+ stream params rpc-meta)
       (sout-add-comma +json-format+ stream)
       (sout-object-attr +json-format+ stream  'number "id" id)
       (sout-add-comma +json-format+ stream)
       (sout-object-attr +json-format+ stream  'number
                         "remote-depth" (1+ *rpc-remote-depth*))
       (when auth-token
         (sout-add-comma +json-format+ stream)
         (sout-object-attr +json-format+ stream  *auth-token-type*
                           "xedauth" auth-token))
       (sout-end-object +json-format+ stream "request")) id)))

(defun json-rpc-2-ctor-call-info
    (host host-token auth-token package name &rest args)
  (let ((rpc-meta (get-rpc-meta-data package name)))
    (assert rpc-meta) ;;we expect uniformity between client and server
    (let ((params (make-rpc-params rpc-meta args)))
      (let ((json-request-str (ctor-json-request-str package name params rpc-meta auth-token)))
        (let* ((uri-path (get-handler-uri-path +json-rpc-2-prefix+))
               (full-uri (make-base-url "https"
                                        *reverse-proxy-https-port* host uri-path))
               (parameters (list (cons "request" json-request-str)
                                 (cons "method"
                                       (json-method-string package name)))))
          (when host-token
            (push (cons "host" (host:my-hostname)) parameters)
            (push (cons "token" host-token) parameters))
          (values full-uri parameters rpc-meta))))))

(defun json-rpc-2-call-http
    (host host-token auth-token http-method package name &rest args)
  (multiple-value-bind (full-uri parameters rpc-meta)
      (apply #'json-rpc-2-ctor-call-info host host-token auth-token
             package name args)
    (multiple-value-bind (json-resp-str http-code http-headers)
        (drakma:http-request full-uri
                             :method http-method
                             :parameters parameters)
      (declare (ignorable http-headers))
      (unless (= http-code 200)
        (error "http non OK status ~A" http-code))
      (with-input-from-string (stream json-resp-str)
        (decode-json-rpc-2-response rpc-meta stream)))))

(defun decode-json-rpc-2-response (rpc-meta stream)
  (let ((return-type (rpc-meta-return-type rpc-meta))
        (response nil)
        (error nil))
    (sin-begin-object +json-format+ stream nil)
    (util:while (not (sin-end-object +json-format+ stream nil))
      (let ((key (sin-object-attr-name +json-format+ stream nil)))
        (sin-attr-name-value-seprator +json-format+ stream)
        (with-hashed-identity (:test #'equal)
          (case key
            ("result"
             (setf response
                   (if (consp return-type)
                       (deserialize-compound-type
                        +json-format+ stream nil return-type)
                       (funcall (get-deserializer return-type)
                                +json-format+ stream return-type))))
            ("id" (deserialize-compound-type +json-format+ stream nil
                                             '(or null integer)))
            ("jsonrpc" (deserialize-string +json-format+ stream 'string))
            ("error"
             (let ((json-rpc-error (funcall (get-deserializer 'json-rpc-2-error)
                                            +json-format+ stream 'json-rpc-2-error)))
               (setf error (make-condition
                            'rpc-error
                            :cause json-rpc-error))))
            (t (error "unknown attribute ~A in json request " key))
            ))
        (sin-attr-separator  +json-format+ stream)))
    (if error
        (error error)
        response)))

;;todo 2 somehow have ability to switch transport/formats (say xml instead of json)
(defun call-remote-anon (host function &rest args)
  (log:with-logged-error
    (multiple-value-bind (package name)
        (rpc-reverse-lookup function)
      (or (and package function) (error "not an rpc function"))
      (apply #'json-rpc-2-call-http host nil nil :post package name args))))

(defun call-remote-impersonate (host function auth-token &rest args)
  (log:with-logged-error
    (multiple-value-bind (package name)
        (rpc-reverse-lookup function)
      (or (and package function) (error "not an rpc function"))
      (apply #'json-rpc-2-call-http host nil auth-token
             :post package name args))))

(defun call-remote-trust-impersonate (host function auth-token &rest args)
  (apply #'call-remote-impl host function auth-token args))

(defun call-remote-trust (host function &rest args)
  (apply #'call-remote-impl host function nil args))

(defun call-remote-impl (host function user-token &rest args)
  (if (and *optimize-local-calls*
           (equal host (host:my-hostname)))
      (call-rpc-local function args)
      (let ((token (establish-trust host)))
        (log:with-logged-error
          (multiple-value-bind (package name)
              (rpc-reverse-lookup function)
            (or (and package function) (error "not an rpc function"))
            (apply #'json-rpc-2-call-http host token user-token :post package name args))))))

(defun ctor-call-remote-url (host function &rest args)
  (multiple-value-bind (package name)
      (rpc-reverse-lookup function)
    (or (and package function) (error "not an rpc function"))
    (multiple-value-bind (full-uri parameters rpc-meta)
        (apply #'json-rpc-2-ctor-call-info host nil nil
               package name args)
      (declare (ignorable rpc-meta))
      (make-full-url full-uri parameters))))

(defun call-rpc-local (function args)
  (multiple-value-bind (package name)
      (rpc-reverse-lookup function)
    (let ((rpc-meta (get-rpc-meta-data package name)))
      (let ((params (make-rpc-params rpc-meta args)))
        (let ((args (list)))
          (mapc (lambda (param)
                  (push (keyword-from-symbol (car param)) args)
                  (push (cdr param) args))
                params)
          (setf args (nreverse args))
          (apply function args))))))
